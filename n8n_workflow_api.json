{
  "name": "My workflow - HYBRID (Individual Agents + Optimizations)",
  "nodes": [
    {
      "parameters": {
        "jsCode": "const input = $input.first().json['What movie are you looking for?']\nreturn {\n  cleanedInput: input.toLowerCase().replace(/[^a-z0-9\\s]/gi, ''),\n  rawInput: $input.first().json['What movie are you looking for?']\n};"
      },
      "id": "fdd5d437-2084-4d16-9921-185d2f4e7c5b",
      "name": "normalize_user_input",
      "type": "n8n-nodes-base.code",
      "position": [
        -672,
        112
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {}
      },
      "id": "bb3487dd-a9d7-4702-8d2f-0b38b01f6148",
      "name": "OpenAI Chat Model1",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        -384,
        544
      ],
      "typeVersion": 1.2,
      "credentials": {}
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"reference_movie\": true,\n  \"title_keywords\": false,\n  \"genres\": true,\n  \"overview_keywords\": true,\n  \"year_range\": false,\n  \"runtime_range\": true,\n  \"original_language\": false,\n  \"main_actors\": false,\n  \"director\": false\n}",
        "autoFix": true
      },
      "id": "37f03a3a-d9e6-49a9-8c68-0af42bbd1a50",
      "name": "Structured Output Parser1",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "position": [
        -368,
        336
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are an intelligent assistant that analyzes natural language movie search requests.\n\nYour task is to detect which structured movie fields are semantically relevant or implied in the user's input.\n\nReturn a JSON object with the following fields. For each field, return `true` if the user clearly mentions or implies that it matters to their request. Return `false` otherwise.\n\nRespond ONLY with a valid JSON object. Do not include explanations or comments.\n\nList of fields:\n\n- reference_movie: if the user references another movie title as an example of what he wants\n- title_keywords \u2014 if the user gives an approximation of what the title may be or if he gives specific or descriptive words the user wants in the title\n- genres \u2014 genres like Horror, Comedy, Action, Romance\n- overview_keywords \u2014 thematic or content-related words like \"robots\", \"cars\", \"space\", etc.\n- year_range \u2014 references to specific eras (e.g. \"80s\", \"before 2000\", \"recent\")\n- runtime_range \u2014 mentions of movie length (e.g. \"short\", \"around 2 hours\", \"not too long\")\n- original_language \u2014 any mention of language preference (e.g. \"French movie\", \"not dubbed\") or regions that could be assigned to a language (e.g. \"Asiatic\" could be assigned to Japanese or Chinese)\n- main_actors \u2014 specific actors or actresses mentioned\n- director \u2014 any director or filmmaker mentioned\n\nExample output:\n```json\n{\n  \"reference_movie\": true,\n  \"title_keywords\": false,\n  \"genres\": true,\n  \"overview_keywords\": true,\n  \"year_range\": false,\n  \"runtime_range\": true,\n  \"original_language\": false,\n  \"main_actors\": false,\n  \"director\": false\n}\n```\n\nNow analyze the following user request:\n\"\"\"\n{{ $json.cleanedInput }}\n\"\"\"",
        "hasOutputParser": true,
        "options": {}
      },
      "id": "35797fc1-1239-44e9-b29f-73e0fe0f0bbf",
      "name": "AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        -448,
        112
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {}
      },
      "id": "f0f91ee7-4dc7-42f3-95cb-921d8d71b601",
      "name": "OpenAI Chat Model - Extraction",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        112,
        112
      ],
      "typeVersion": 1.2,
      "credentials": {}
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"title_keywords\": [{\"value\": \"Interstellar\", \"weight\": 7}],\n  \"genres\": [{\"value\": \"Science Fiction\", \"weight\": 8}],\n  \"overview_keywords\": [{\"value\": \"space\", \"weight\": 5}],\n  \"year_range\": {\"value\": [2010, 2020], \"weight\": 6},\n  \"runtime_range\": {\"value\": [120, 180], \"weight\": 3},\n  \"original_language\": [{\"value\": \"en\", \"weight\": 4}],\n  \"main_actors\": [{\"value\": \"Matthew McConaughey\", \"weight\": 5}],\n  \"directors\": [{\"value\": \"Christopher Nolan\", \"weight\": 7}],\n  \"title_ref\": [{\"value\": \"Interstellar\", \"weight\": 9}]\n}",
        "autoFix": true
      },
      "id": "8c9fdfc7-9842-4761-aba4-8e13f1608eae",
      "name": "Structured Output Parser - Extraction",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "position": [
        176,
        112
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "jsCode": "// Merge all Switch outputs and pass relevance flags to extraction\nconst allInputs = $input.all();\nconst relevanceFlags = {};\n\n// Collect all relevance flags from Switch outputs\nallInputs.forEach(item => {\n  const output = item.json.output || {};\n  if (output.reference_movie !== undefined) relevanceFlags.reference_movie = output.reference_movie;\n  if (output.title_keywords !== undefined) relevanceFlags.title_keywords = output.title_keywords;\n  if (output.genres !== undefined) relevanceFlags.genres = output.genres;\n  if (output.overview_keywords !== undefined) relevanceFlags.overview_keywords = output.overview_keywords;\n  if (output.year_range !== undefined) relevanceFlags.year_range = output.year_range;\n  if (output.runtime_range !== undefined) relevanceFlags.runtime_range = output.runtime_range;\n  if (output.original_language !== undefined) relevanceFlags.original_language = output.original_language;\n  if (output.main_actors !== undefined) relevanceFlags.main_actors = output.main_actors;\n  if (output.director !== undefined) relevanceFlags.director = output.director;\n});\n\n// Get cleaned input\nconst cleanedInput = $('normalize_user_input').item.json.cleanedInput;\n\nreturn [{\n  json: {\n    relevanceFlags,\n    cleanedInput,\n    rawInput: $('normalize_user_input').item.json.rawInput\n  }\n}];"
      },
      "id": "80101797-9100-425b-b3d2-6fdc0b5c2d0c",
      "name": "Merge Relevance Flags",
      "type": "n8n-nodes-base.code",
      "position": [
        320,
        0
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are analyzing a user query for movie search. Extract ALL relevant information from the user's message.\n\nIMPORTANT: Return ONLY valid JSON. No explanations, no markdown, no code blocks. Just the JSON object.\n\nExtract the following fields (only extract fields that are mentioned - leave empty if not mentioned):\n\n1. **title_keywords**: Movie titles the user is actually looking for (not references). Weight 8-10 for clear titles, 4-7 for variants, 1-3 for vague matches. Return as array: [{\"value\": \"title\", \"weight\": number}]\n\n2. **genres**: Genres mentioned or implied. Allowed: Thriller, Horror, Drama, Comedy, Adventure, Action, Science Fiction, Romance, War, Crime, History, Music, Mystery, Family, Fantasy, Western, Animation, Documentary, TV Movie. Weight 8-10 for specific genres, 4-7 for vague. Return as array: [{\"value\": \"genre\", \"weight\": number}]\n\n3. **overview_keywords**: Thematic keywords (max 5, single words). Weight 5-10 if important. Return as array: [{\"value\": \"keyword\", \"weight\": number}]\n\n4. **year_range**: Release year range. Weight 8-10 for specific years/ranges, 4-7 for vague. Return as object: {\"value\": [min_year, max_year], \"weight\": number}. If not mentioned, return {\"value\": [], \"weight\": 0}\n\n5. **runtime_range**: Movie length. Weight 8-10 for specific runtime, 4-7 for vague. Normal range is [90, 120]. Return as object: {\"value\": [min_minutes, max_minutes], \"weight\": number}. If not mentioned, return {\"value\": [], \"weight\": 0}\n\n6. **original_language**: Language codes only (en, it, es, ja, fr, zh, el, cn, ru, de, pt, te, hi, pl, he, sh, nl, ko, sv, tr, da, tl, fa, ar, zu, mr, cs, id, fi, lv, bn, or, ta, ml, hu, sr, no, th, kn, lt, jv, uk, ho, ki, xx, af, mn). Weight 8-10 for specific language. Return as array: [{\"value\": \"en\", \"weight\": number}]\n\n7. **main_actors**: Actors mentioned. Weight 5-10 for specific actors. Return as array: [{\"value\": \"actor name\", \"weight\": number}]\n\n8. **directors**: Directors mentioned. Weight 5-10 for specific directors. Return as array: [{\"value\": \"director name\", \"weight\": number}]\n\n9. **title_ref**: Movie titles used as REFERENCES/examples (e.g., \"similar to Interstellar\", \"like Toy Story\"). Weight 1-10. Return as array: [{\"value\": \"movie title\", \"weight\": number}]\n\n---\n\nCRITICAL: Return ONLY this exact JSON structure (all fields must be present, use empty arrays/objects if not mentioned):\n\n{\n  \"title_keywords\": [],\n  \"genres\": [],\n  \"overview_keywords\": [],\n  \"year_range\": {\"value\": [], \"weight\": 0},\n  \"runtime_range\": {\"value\": [], \"weight\": 0},\n  \"original_language\": [],\n  \"main_actors\": [],\n  \"directors\": [],\n  \"title_ref\": []\n}\n\nNow analyze this user request and return ONLY the JSON (no markdown, no code blocks, no explanations):\n\"\"\"\n{{ $json.cleanedInput }}\n\"\"\"",
        "hasOutputParser": true,
        "options": {}
      },
      "id": "b16c7e2e-77f6-4232-89b3-751a256d0b93",
      "name": "Comprehensive Extraction Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        512,
        0
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "a11682fb-34f1-486b-83bf-d43853e8fb56",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.title_keywords }}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "title"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "3b7ec878-30fb-413d-bba0-a94f196ccc44",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.genres }}",
                    "rightValue": "true"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "genres"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "6207e214-f927-4371-9dbe-3dbf4bd0a523",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.overview_keywords }}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "overview"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "75090c2f-451e-4986-b5c5-32210996f24f",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.year_range}}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "year"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "b49d6e37-bfde-4dfb-bb06-e03c91b10317",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.runtime_range }}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "runtime"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "8539bf87-0f68-4bd4-bb16-148e44d18d69",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.original_language }}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "original_language"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "f24c9e0a-4087-4758-82c1-d2d8340fd3d2",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.main_actors }}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "main_actors"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "8b58eaaa-5547-4cde-a6dd-8332d66ee943",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.director }}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "director"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "a9220319-58e6-4923-aa7a-6b2248342676",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.reference_movie }}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "reference"
            }
          ]
        },
        "options": {
          "allMatchingOutputs": true
        }
      },
      "id": "9fa99632-6fda-463b-b4a0-cc64bc2b369f",
      "name": "Switch",
      "type": "n8n-nodes-base.switch",
      "position": [
        0,
        0
      ],
      "typeVersion": 3.2
    },
    {
      "parameters": {
        "jsCode": "// Extract output from comprehensive extraction agent\nconst output = $input.first().json.output || $input.first().json;\nreturn [{ json: output }];"
      },
      "id": "71639017-163c-4b2b-8824-cfcbf4375b75",
      "name": "Extract Extraction Output",
      "type": "n8n-nodes-base.code",
      "position": [
        320,
        0
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "// Process reference movies if present and prepare FirstJSON\nconst input = $input.first().json;\nconst titleRef = input.title_ref || [];\n\n// Prepare FirstJSON structure\nconst firstJSON = {\n  title_keywords: input.title_keywords || [],\n  genres: input.genres || [],\n  overview_keywords: input.overview_keywords || [],\n  year_range: input.year_range || { value: [], weight: 0 },\n  runtime_range: input.runtime_range || { value: [], weight: 0 },\n  original_language: input.original_language || [],\n  main_actors: input.main_actors || [],\n  directors: input.directors || []\n};\n\nreturn [{\n  json: {\n    FirstJSON: firstJSON,\n    title_ref: titleRef\n  }\n}];"
      },
      "id": "e452e2eb-1e27-4bac-bcf1-83ba1fe3965f",
      "name": "Prepare JSON",
      "type": "n8n-nodes-base.code",
      "position": [
        912,
        0
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Process reference movies if title_ref exists\nSET @my_json = '[{{ JSON.stringify({ title_ref: $json.title_ref || [] }) }}]';\n\n-- Check if we have reference movies first (without creating temp table)\nSET @has_refs = (\n  SELECT COUNT(*)\n  FROM JSON_TABLE(@my_json, '$[*]' COLUMNS (title_ref JSON PATH '$.title_ref')) AS jt\n  CROSS JOIN JSON_TABLE(jt.title_ref, '$[*]' COLUMNS (title_ref_elem JSON PATH '$')) AS jtr\n);\n\n-- If no reference movies, return empty SecondJSON immediately\nSELECT IF(@has_refs = 0,\n  JSON_ARRAY(JSON_OBJECT(\n    'title_keywords', JSON_ARRAY(),\n    'genres', JSON_ARRAY(),\n    'year_range', JSON_OBJECT('value', JSON_ARRAY(), 'weight', 0),\n    'runtime_range', JSON_OBJECT('value', JSON_ARRAY(), 'weight', 0),\n    'original_language', JSON_ARRAY(),\n    'main_actors', JSON_ARRAY(),\n    'directors', JSON_ARRAY(),\n    'rejected_ids', JSON_ARRAY()\n  )),\n  (\n    -- Process reference movies - use CTEs directly from JSON_TABLE (no temp tables)\n    WITH ref_titles AS (\n      SELECT\n        JSON_UNQUOTE(JSON_EXTRACT(jtr.title_ref_elem, '$.value')) AS value,\n        JSON_UNQUOTE(JSON_EXTRACT(jtr.title_ref_elem, '$.weight')) AS weight\n      FROM JSON_TABLE(@my_json, '$[*]' COLUMNS (title_ref JSON PATH '$.title_ref')) AS jt\n      CROSS JOIN JSON_TABLE(jt.title_ref, '$[*]' COLUMNS (title_ref_elem JSON PATH '$')) AS jtr\n    ),\n    matching_movies AS (\n      SELECT \n        m.runtime, m.original_language, m.genres, m.main_actors,\n        m.director, m.year, rt.weight, m.Id AS rejected_ids\n      FROM ref_titles AS rt\n      JOIN tmdb_movies AS m ON SOUNDEX(m.title) = SOUNDEX(rt.value)\n    ),\n    aggregated_data AS (\n      SELECT\n        ROUND(AVG(weight), 0) AS avg_weight,\n        IFNULL(MIN(runtime), 0) AS runtime_min,\n        IFNULL(MAX(runtime), 0) AS runtime_max,\n        IFNULL(MIN(year), 0) AS year_min,\n        IFNULL(MAX(year), 0) AS year_max\n      FROM matching_movies\n    )\n    SELECT JSON_ARRAY(\n      JSON_OBJECT(\n        'title_keywords', JSON_ARRAY(),\n        'genres', IFNULL((SELECT JSON_ARRAYAGG(JSON_OBJECT('value', genre_name, 'weight', ad.avg_weight))\n          FROM (SELECT DISTINCT TRIM(genre) AS genre_name FROM matching_movies\n          JOIN JSON_TABLE(CONCAT('[\"', REPLACE(REPLACE(genres, ';', ','), ',', '\",\"'), '\"]'),\n          '$[*]' COLUMNS (genre VARCHAR(100) PATH '$')) AS g) AS unique_genres\n          CROSS JOIN aggregated_data ad), JSON_ARRAY()),\n        'year_range', JSON_OBJECT('value', JSON_ARRAY(ad.year_min, ad.year_max), 'weight', ad.avg_weight),\n        'runtime_range', JSON_OBJECT('value', JSON_ARRAY(ad.runtime_min, ad.runtime_max), 'weight', ad.avg_weight),\n        'original_language', IFNULL((SELECT JSON_ARRAYAGG(JSON_OBJECT('value', language_code, 'weight', ad.avg_weight))\n          FROM (SELECT DISTINCT TRIM(lang) AS language_code FROM matching_movies\n          JOIN JSON_TABLE(CONCAT('[\"', REPLACE(REPLACE(original_language, ';', ','), ',', '\",\"'), '\"]'),\n          '$[*]' COLUMNS (lang VARCHAR(10) PATH '$')) AS l) AS unique_languages\n          CROSS JOIN aggregated_data ad), JSON_ARRAY()),\n        'main_actors', IFNULL((SELECT JSON_ARRAYAGG(JSON_OBJECT('value', actor_name, 'weight', ad.avg_weight))\n          FROM (SELECT DISTINCT TRIM(actor) AS actor_name FROM matching_movies\n          JOIN JSON_TABLE(CONCAT('[\"', REPLACE(main_actors, ',', '\",\"'), '\"]'),\n          '$[*]' COLUMNS (actor VARCHAR(255) PATH '$')) AS a) AS unique_actors\n          CROSS JOIN aggregated_data ad), JSON_ARRAY()),\n        'directors', IFNULL((SELECT JSON_ARRAYAGG(JSON_OBJECT('value', director_name, 'weight', ad.avg_weight))\n          FROM (SELECT DISTINCT TRIM(d.director_name) AS director_name FROM matching_movies AS m\n          JOIN JSON_TABLE(CONCAT('[\"', REPLACE(REPLACE(m.director, ';', ','), ',', '\",\"'), '\"]'),\n          '$[*]' COLUMNS (director_name VARCHAR(255) PATH '$')) AS d) AS unique_directors\n          CROSS JOIN aggregated_data ad), JSON_ARRAY()),\n        'rejected_ids', IFNULL((SELECT JSON_ARRAYAGG(rejected_ids) FROM matching_movies), JSON_ARRAY())\n      )\n    )\n    FROM aggregated_data ad\n  )\n) AS result_json;",
        "options": {}
      },
      "id": "9207c841-6326-465b-b062-ca1962b49d4d",
      "name": "SecondJSON SQL",
      "type": "n8n-nodes-base.mySql",
      "position": [
        1120,
        0
      ],
      "typeVersion": 2.4,
      "credentials": {}
    },
    {
      "parameters": {
        "jsCode": "// Merge FirstJSON and SecondJSON\nconst firstItems = $input.all('Prepare JSON') || [];\nconst firstJson = firstItems[0]?.json?.FirstJSON || {};\n\nconst secondItems = $input.all('SecondJSON SQL') || [];\nconst secondJson = secondItems[0]?.json?.result_json?.[0] || {};\n\n// Merge year_range\nlet year_range = null;\nif (firstJson.year_range && secondJson.year_range && secondJson.year_range.value && secondJson.year_range.value.length === 2) {\n  const avgLower = Math.round((firstJson.year_range.value[0] + secondJson.year_range.value[0]) / 2);\n  const avgUpper = Math.round((firstJson.year_range.value[1] + secondJson.year_range.value[1]) / 2);\n  const avgWeight = Math.round((firstJson.year_range.weight + secondJson.year_range.weight) / 2);\n  year_range = { value: [avgLower, avgUpper], weight: avgWeight };\n} else if (firstJson.year_range && firstJson.year_range.value && firstJson.year_range.value.length === 2) {\n  year_range = firstJson.year_range;\n} else if (secondJson.year_range && secondJson.year_range.value && secondJson.year_range.value.length === 2) {\n  year_range = secondJson.year_range;\n} else {\n  year_range = { value: [], weight: 0 };\n}\n\n// Merge runtime_range\nlet runtime_range = null;\nif (firstJson.runtime_range && secondJson.runtime_range && secondJson.runtime_range.value && secondJson.runtime_range.value.length === 2) {\n  const avgLower = Math.round((firstJson.runtime_range.value[0] + secondJson.runtime_range.value[0]) / 2);\n  const avgUpper = Math.round((firstJson.runtime_range.value[1] + secondJson.runtime_range.value[1]) / 2);\n  const avgWeight = Math.round((firstJson.runtime_range.weight + secondJson.runtime_range.weight) / 2);\n  runtime_range = { value: [avgLower, avgUpper], weight: avgWeight };\n} else if (firstJson.runtime_range && firstJson.runtime_range.value && firstJson.runtime_range.value.length === 2) {\n  runtime_range = firstJson.runtime_range;\n} else if (secondJson.runtime_range && secondJson.runtime_range.value && secondJson.runtime_range.value.length === 2) {\n  runtime_range = secondJson.runtime_range;\n} else {\n  runtime_range = { value: [], weight: 0 };\n}\n\n// Merge weighted arrays\nfunction mergeWeightedArrays(arr1 = [], arr2 = []) {\n  const map = new Map();\n  function addOrUpdate(item) {\n    if (!item?.value) return;\n    if (map.has(item.value)) {\n      const existing = map.get(item.value);\n      existing.weight = Math.round((existing.weight + item.weight) / 2);\n    } else {\n      map.set(item.value, { ...item });\n    }\n  }\n  arr1.forEach(addOrUpdate);\n  arr2.forEach(addOrUpdate);\n  return Array.from(map.values());\n}\n\nconst finalJson = {\n  title_keywords: firstJson.title_keywords || [],\n  overview_keywords: firstJson.overview_keywords || [],\n  rejected_ids: secondJson.rejected_ids || [],\n  year_range,\n  runtime_range,\n  genres: mergeWeightedArrays(firstJson.genres || [], secondJson.genres || []),\n  original_language: mergeWeightedArrays(firstJson.original_language || [], secondJson.original_language || []),\n  main_actors: mergeWeightedArrays(firstJson.main_actors || [], secondJson.main_actors || []),\n  directors: mergeWeightedArrays(firstJson.directors || [], secondJson.directors || [])\n};\n\nreturn [{ json: finalJson }];"
      },
      "id": "38f265bd-2ba1-41d7-b37e-c6d56fc2ea40",
      "name": "Merge JSON",
      "type": "n8n-nodes-base.code",
      "position": [
        1312,
        0
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "set @json_exclusions ='{{ JSON.stringify({ rejected_ids: $json.rejected_ids || [] }) }}';\nSET @actors_json = '{{ JSON.stringify({ main_actors: $json.main_actors || [] }) }}';\nSET @directors_json = '{{ JSON.stringify({ directors: $json.directors || [] }) }}';\nSET @genres_json = '{{ JSON.stringify({ genres: $json.genres || [] }) }}';\nSET @title_json = '{{ JSON.stringify({ title_keywords: $json.title_keywords || [] }) }}';\nSET @overview_json = '{{ JSON.stringify({ overview_keywords: $json.overview_keywords || [] }) }}';\nSET @lenguage_json = '{{ JSON.stringify({ original_language: $json.original_language || [] }) }}';\nSET @runtime_json = '{{ JSON.stringify({ runtime_range: $json.runtime_range || { value: [], weight: 0 } }) }}';\nSET @year_json = '{{ JSON.stringify({ year_range: $json.year_range || { value: [], weight: 0 } }) }}';\n\nSET SESSION group_concat_max_len = 1000000;\n\nSELECT GROUP_CONCAT(CONCAT(JSON_EXTRACT(actor.value, '$.weight'), ' * CASE WHEN main_actors_soundex LIKE \"%', SOUNDEX(JSON_UNQUOTE(JSON_EXTRACT(actor.value, '$.value'))), '%\" THEN 1 ELSE 0 END') SEPARATOR ' + ') INTO @actor_score_expr\nFROM JSON_TABLE(@actors_json, '$.main_actors[*]' COLUMNS (value JSON PATH '$')) AS actor;\n\nSELECT GROUP_CONCAT(CONCAT(JSON_EXTRACT(director.value, '$.weight'), ' * CASE WHEN directors_soundex LIKE \"%', SOUNDEX(JSON_UNQUOTE(JSON_EXTRACT(director.value, '$.value'))), '%\" THEN 1 ELSE 0 END') SEPARATOR ' + ') INTO @director_score_expr\nFROM JSON_TABLE(@directors_json, '$.directors[*]' COLUMNS (value JSON PATH '$')) AS director;\n\nSELECT GROUP_CONCAT(CONCAT(JSON_EXTRACT(genre.value, '$.weight'), ' * CASE WHEN genres LIKE \"%', JSON_UNQUOTE(JSON_EXTRACT(genre.value, '$.value')), '%\" THEN 1 ELSE 0 END') SEPARATOR ' + ') INTO @genre_score_expr\nFROM JSON_TABLE(@genres_json, '$.genres[*]' COLUMNS (value JSON PATH '$')) AS genre;\n\nSELECT GROUP_CONCAT(CONCAT(JSON_EXTRACT(t.value, '$.weight'), ' * CASE WHEN title_soundex LIKE \"%', SOUNDEX(JSON_UNQUOTE(JSON_EXTRACT(t.value, '$.value'))), '%\" THEN 1 ELSE 0 END') SEPARATOR ' + ') INTO @title_score_expr\nFROM JSON_TABLE(@title_json, '$.title_keywords[*]' COLUMNS (value JSON PATH '$')) AS t;\n\nSELECT GROUP_CONCAT(CONCAT(JSON_EXTRACT(k.value, '$.weight'), ' * CASE WHEN overview LIKE \"%', JSON_UNQUOTE(JSON_EXTRACT(k.value, '$.value')), '%\" THEN 1 ELSE 0 END') SEPARATOR ' + ') INTO @overview_score_expr\nFROM JSON_TABLE(@overview_json, '$.overview_keywords[*]' COLUMNS (value JSON PATH '$')) AS k;\n\nSELECT GROUP_CONCAT(CONCAT(JSON_EXTRACT(lang.value, '$.weight'), ' * CASE WHEN original_language = \"', JSON_UNQUOTE(JSON_EXTRACT(lang.value, '$.value')), '\" THEN 1 ELSE 0 END') SEPARATOR ' + ') INTO @language_score_expr\nFROM JSON_TABLE(@lenguage_json, '$.original_language[*]' COLUMNS (value JSON PATH '$')) AS lang;\n\nSELECT CONCAT('CASE ', 'WHEN runtime >= ', JSON_EXTRACT(j.value, '$.value[0]'), ' AND runtime <= ', JSON_EXTRACT(j.value, '$.value[1]'), ' THEN ', JSON_EXTRACT(j.value, '$.weight'), ' WHEN runtime < ', JSON_EXTRACT(j.value, '$.value[0]'), ' THEN ', JSON_EXTRACT(j.value, '$.weight'), '/(1 + LN(1 + ABS(', JSON_EXTRACT(j.value, '$.value[0]'), ' - runtime)))', ' WHEN runtime > ', JSON_EXTRACT(j.value, '$.value[1]'), ' THEN ', JSON_EXTRACT(j.value, '$.weight'), '/(1 + LN(1 + ABS(', JSON_EXTRACT(j.value, '$.value[1]'), ' - runtime)))', ' END') INTO @runtime_score_expr\nFROM JSON_TABLE(@runtime_json, '$.runtime_range' COLUMNS (value JSON PATH '$')) AS j;\n\nSELECT CONCAT('CASE ', 'WHEN year >= ', JSON_EXTRACT(j.value, '$.value[0]'), ' AND year <= ', JSON_EXTRACT(j.value, '$.value[1]'), ' THEN ', JSON_EXTRACT(j.value, '$.weight'), ' WHEN year < ', JSON_EXTRACT(j.value, '$.value[0]'), ' THEN ', JSON_EXTRACT(j.value, '$.weight'), '/(1 + LN(1 + ABS(', JSON_EXTRACT(j.value, '$.value[0]'), ' - year)))', ' WHEN year > ', JSON_EXTRACT(j.value, '$.value[1]'), ' THEN ', JSON_EXTRACT(j.value, '$.weight'), '/(1 + LN(1 + ABS(', JSON_EXTRACT(j.value, '$.value[1]'), ' - year)))', ' END') INTO @year_score_expr\nFROM JSON_TABLE(@year_json, '$.year_range' COLUMNS (value JSON PATH '$')) AS j;\n\nSET @sql = CONCAT('WITH rejected AS (SELECT id FROM JSON_TABLE(', QUOTE(@json_exclusions), ', \"$.rejected_ids[*]\" COLUMNS (id INT PATH \"$\")) AS rej), movies_with_score AS (SELECT title, id, year, ', IFNULL(@actor_score_expr, '0'), ' + ', IFNULL(@director_score_expr, '0'), ' + ', IFNULL(@genre_score_expr, '0'), ' + ', IFNULL(@title_score_expr, '0'), ' + ', IFNULL(@overview_score_expr, '0'), ' + ', IFNULL(@language_score_expr, '0'), ' + ', IFNULL(@runtime_score_expr, '0'), ' + ', IFNULL(@year_score_expr, '0'), ' AS score FROM tmdb_movies WHERE id NOT IN (SELECT id FROM rejected)), ranked_movies AS (SELECT *, DENSE_RANK() OVER (ORDER BY score DESC) AS rank_col FROM movies_with_score) SELECT title, id, year, score FROM ranked_movies ORDER BY rank_col ASC LIMIT 5');\n\nPREPARE stmt FROM @sql;\nEXECUTE stmt;\nDEALLOCATE PREPARE stmt;",
        "options": {}
      },
      "id": "061f2636-2b9d-4ffa-b85d-909d8ce6f923",
      "name": "Execute SQL Query",
      "type": "n8n-nodes-base.mySql",
      "position": [
        1520,
        0
      ],
      "typeVersion": 2.4,
      "credentials": {}
    },
    {
      "parameters": {
        "jsCode": "// Split results for parallel TMDB API calls\nconst results = $input.all();\nreturn results.map(item => ({ json: { title: item.json.title, id: item.json.id, year: item.json.year, score: item.json.score } }));"
      },
      "id": "d1376770-4967-49b3-8adc-5650e2b310de",
      "name": "Split for TMDB",
      "type": "n8n-nodes-base.code",
      "position": [
        1712,
        0
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "url": "=https://api.themoviedb.org/3/search/movie",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "api_key",
              "value": "YOUR_TMDB_API_KEY_HERE"
            },
            {
              "name": "query",
              "value": "={{ $json.title }}"
            },
            {
              "name": "year",
              "value": "={{ $json.year }}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "14cc6f5e-5c75-4bdd-b8f1-b466bebd85ee",
      "name": "TMDB Search",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        1920,
        0
      ],
      "typeVersion": 4.2
    },
    {
      "parameters": {
        "jsCode": "// Match TMDB result with SQL result and enrich data\nconst sqlData = $('Split for TMDB').item.json;\nconst tmdbResults = $json.results || [];\n\n// Find best match (exact title match preferred, then closest year)\nlet bestMatch = null;\nif (tmdbResults.length > 0) {\n  // Try exact title match first\n  bestMatch = tmdbResults.find(r => \n    r.title.toLowerCase() === sqlData.title.toLowerCase()\n  );\n  \n  // If no exact match, try closest year\n  if (!bestMatch && sqlData.year) {\n    bestMatch = tmdbResults.reduce((best, current) => {\n      const currentDiff = Math.abs((current.release_date ? parseInt(current.release_date.split('-')[0]) : 0) - sqlData.year);\n      const bestDiff = best ? Math.abs((best.release_date ? parseInt(best.release_date.split('-')[0]) : 0) - sqlData.year) : Infinity;\n      return currentDiff < bestDiff ? current : best;\n    }, null);\n  }\n  \n  // Fallback to first result\n  if (!bestMatch) {\n    bestMatch = tmdbResults[0];\n  }\n}\n\n// Return enriched movie data\nreturn [{\n  json: {\n    id: bestMatch?.id || sqlData.id || `movie-${Date.now()}`,\n    tmdb_id: bestMatch?.id,\n    title: bestMatch?.title || sqlData.title,\n    year: bestMatch?.release_date ? parseInt(bestMatch.release_date.split('-')[0]) : sqlData.year || new Date().getFullYear(),\n    poster: bestMatch?.poster_path ? `https://image.tmdb.org/t/p/w500${bestMatch.poster_path}` : null,\n    description: bestMatch?.overview || `A recommended film: ${sqlData.title}`,\n    rating: bestMatch?.vote_average ? (bestMatch.vote_average / 10) * 10 : 8.0,\n    vote_count: bestMatch?.vote_count || 0,\n    score: sqlData.score || 0,\n    original_title: bestMatch?.original_title || sqlData.title,\n    backdrop_path: bestMatch?.backdrop_path ? `https://image.tmdb.org/t/p/w1280${bestMatch.backdrop_path}` : null\n  }\n}];"
      },
      "id": "86fea6c3-bde0-4a08-bcc5-cb970af61b0e",
      "name": "Enrich with TMDB",
      "type": "n8n-nodes-base.code",
      "position": [
        2112,
        0
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "// Format final response with all movies sorted by score\nconst results = $input.all();\n\n// Sort by score (descending) - best match first\nconst sortedMovies = results\n  .map(item => item.json)\n  .filter(movie => movie.title)\n  .sort((a, b) => (b.score || 0) - (a.score || 0));\n\nconst titles = sortedMovies.map(m => m.title);\n\nreturn [{\n  json: {\n    message: sortedMovies.length > 0 ? `I found ${sortedMovies.length} movie${sortedMovies.length > 1 ? 's' : ''} for you!` : \"No movies found\",\n    allTitles: titles,\n    titlesString: titles.join(\", \"),\n    movies: sortedMovies.map((movie, index) => ({\n      id: movie.tmdb_id || movie.id || `movie-${index}-${Date.now()}`,\n      title: movie.title || 'Unknown',\n      year: movie.year || new Date().getFullYear(),\n      poster: movie.poster || null,\n      description: movie.description || `A recommended film: ${movie.title}`,\n      rating: movie.rating || 8.0,\n      score: movie.score || 0,\n      backdrop_path: movie.backdrop_path || null,\n      vote_count: movie.vote_count || 0\n    })),\n    success: sortedMovies.length > 0\n  }\n}];"
      },
      "id": "70510df2-6bb5-464c-a5e2-14e6a7aa8a3d",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "position": [
        2320,
        0
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "// Extract message from request body\nconst body = $input.first().json.body || $input.first().json;\nconst userMessage = body.message || body.text || JSON.stringify(body);\n\nreturn [{\n  json: {\n    \"What movie are you looking for?\": userMessage,\n    originalMessage: userMessage,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "8639db09-d68a-498c-b860-5776b994ac9d",
      "name": "Extract Message",
      "type": "n8n-nodes-base.code",
      "position": [
        -1312,
        304
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini",
          "cachedResultName": "gpt-4.1-mini"
        },
        "options": {}
      },
      "id": "b64f1a14-ee46-483a-bf29-486c907f2f60",
      "name": "OpenAI Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        27376,
        31504
      ],
      "typeVersion": 1.2,
      "credentials": {}
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"genres\": [\n    {\n      \"value\": \"Science Fiction\",\n      \"weight\": 3\n    },\n    {\n      \"value\": \"Drama\",\n      \"weight\": 2\n    }\n  ]\n}",
        "autoFix": true
      },
      "id": "b5ad438c-df07-4757-a2aa-9e113774d16a",
      "name": "Structured Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "position": [
        27376,
        31296
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini",
          "cachedResultName": "gpt-4.1-mini"
        },
        "options": {}
      },
      "id": "1cb14f66-0c41-4fee-8593-4911011f1648",
      "name": "OpenAI Chat Model2",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        27376,
        30896
      ],
      "typeVersion": 1.2,
      "credentials": {}
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"title_keywords\": [\n    {\n      \"value\": \"Toy Story\",\n      \"weight\": 7\n    },\n    {\n      \"value\": \"Interestelar\",\n      \"weight\": 7\n    }\n  ]\n}",
        "autoFix": true
      },
      "id": "99c2a3c1-4772-4bd7-ac01-ec14e17d91e2",
      "name": "Structured Output Parser2",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "position": [
        27376,
        30688
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=If there isn't enought information, leave the field empty.\n\nYou are analyzing a user query for movie search. Your job is to determine if the user cares about the **genre** of the movie, and if so:\n\n1. Extract **genres** that the user refers to or implies\n2. Assign a **weight from 1 to 10** based on how important the genres are in their message\n\nGuidelines:\n- If the user names a specific genre, give it a high weight (8\u201310)\n- If the user references a vague genre (\"scary\", \"funny\"), assign a medium weight (4\u20137)\n- If the user mentions a genre but it doen't seem important to him, assign a low weight (1\u20133)\n- The allowed genres you can include in the output are:\nThriller, Horror, Drama, Comedy, Adventure, Action, Science Fiction, Romance, War, Crime, History, Music, Mystery, Family, Fantasy, Western, Animation, Documentary, TV Movie\n---\n\n### Output must be ONLY a valid JSON object with this structure:\n\n```json\n{\n  \"genres\": [\n    {\n      \"value\": \"Science Fiction\",\n      \"weight\": 3\n    },\n    {\n      \"value\": \"Drama\",\n      \"weight\": 2\n    }\n  ]\n}\n\nNow analyze the following user request:\n\"\"\"\n{{ $('normalize_user_input1').item.json.cleanedInput }}\n\"\"\"",
        "hasOutputParser": true,
        "options": {}
      },
      "id": "4061a8cf-5282-49ad-94d2-99f9cb41c536",
      "name": "Genres",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        27312,
        31072
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini",
          "cachedResultName": "gpt-4.1-mini"
        },
        "options": {}
      },
      "id": "588ac3d8-905b-4f64-a144-250a72cc66bf",
      "name": "OpenAI Chat Model3",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        27376,
        33936
      ],
      "typeVersion": 1.2,
      "credentials": {}
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"original_language\": [\n    {\n      \"value\": \"en\",\n      \"weight\": 6\n    },\n    {\n      \"value\": \"fr\",\n      \"weight\": 10\n    }\n  ]\n}",
        "autoFix": true
      },
      "id": "9f122ce8-2302-4f2e-9ffa-36e71cdcd406",
      "name": "Structured Output Parser3",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "position": [
        27376,
        33728
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini",
          "cachedResultName": "gpt-4.1-mini"
        },
        "options": {}
      },
      "id": "979d6826-b52a-4e86-943a-0925b7105cf8",
      "name": "OpenAI Chat Model4",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        27376,
        32112
      ],
      "typeVersion": 1.2,
      "credentials": {}
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"overview_keywords\": [\n    {\n      \"value\": \"space\",\n      \"weight\": 3\n    },\n    {\n      \"value\": \"black hole\",\n      \"weight\": 5\n    },\n    {\n      \"value\": \"father-daughter\",\n      \"weight\": 10\n    }\n  ]\n}",
        "autoFix": true
      },
      "id": "87c4a995-ff83-43dd-a380-afb7191c3d47",
      "name": "Structured Output Parser4",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "position": [
        27376,
        31904
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are analyzing a user query for movie search. Your job is to find **key words** in the user mesage, and if so:\n\n1. Extract **key words** from the user's message\n2. Assign a **weight from 1 to 10** based on how important these keywords are in their message\n\nGuidelines:\n- If the key word seems really important, give it a high weight (5\u201310)\n- If the key word doesn't seem important to him, assign a low weight (1\u20135)\n- Extract a maximum of 5 keywords; the most important ones\n- Key words must be only one word\n- Key words can be genres or names of directors, actors or other movies\n---\n\n### Output must be ONLY a valid JSON object with this structure:\n\n```json\n{\n  \"overview_keywords\": [\n    {\n      \"value\": \"space\",\n      \"weight\": 3\n    },\n    {\n      \"value\": \"black hole\",\n      \"weight\": 5\n    },\n    {\n      \"value\": \"father-daughter\",\n      \"weight\": 10\n    }\n  ]\n}\n\nNow analyze the following user request:\n\"\"\"\n{{ $('normalize_user_input1').item.json.cleanedInput }}\n\"\"\"",
        "hasOutputParser": true,
        "options": {}
      },
      "id": "f758b40b-cbe4-4b3e-b4ef-4c68835dbafe",
      "name": "Keywords",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        27312,
        31680
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini",
          "cachedResultName": "gpt-4.1-mini"
        },
        "options": {}
      },
      "id": "370262c8-a81e-4103-a356-0efffdd16db6",
      "name": "OpenAI Chat Model5",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        27376,
        32720
      ],
      "typeVersion": 1.2,
      "credentials": {}
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"year_range\": {\n    \"value\": [\n      2000,\n      2015\n    ],\n    \"weight\": 4\n  }\n}",
        "autoFix": true
      },
      "id": "14e5f2dd-e2f6-4279-88fc-1bef93920ddc",
      "name": "Structured Output Parser5",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "position": [
        27376,
        32512
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are analyzing a user query for movie search. Your job is to determine if the user cares about the **year** where the movie was released, and if so:\n\n1. Extract **year range** where the user refers to or implies\n2. Assign a **weight from 1 to 10** based on how important the year range is in their message\n\nGuidelines:\n- If the user names a specific year or year range, give it a high weight (8\u201310)\n- If the user references a vague period of time (\"modern\", \"old\"), assign a medium weight (4\u20137)\n- If the user mentions the period it was released but it doen't seem important to him, assign a low weight (1\u20133)\n\n---\n\n### Output must be ONLY a valid JSON object with this structure:\n\n```json\n{\n  \"year_range\": {\n    \"value\": [\n      2000,\n      2015\n    ],\n    \"weight\": 4\n  }\n}\n\nNow analyze the following user request:\n\"\"\"\n{{ $('normalize_user_input1').item.json.cleanedInput }}\n\"\"\"",
        "hasOutputParser": true,
        "options": {}
      },
      "id": "db845779-b734-40be-b737-e26f6879dbe6",
      "name": "Year range",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        27312,
        32288
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini",
          "cachedResultName": "gpt-4.1-mini"
        },
        "options": {}
      },
      "id": "a7a246a3-88a5-4a51-bc02-b46b9b22dd43",
      "name": "OpenAI Chat Model6",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        27376,
        33328
      ],
      "typeVersion": 1.2,
      "credentials": {}
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"runtime_range\": {\n    \"value\": [\n      60,\n      90\n    ],\n    \"weight\": 10\n  }\n}",
        "autoFix": true
      },
      "id": "1920453a-0029-4e5f-a6bf-9ed3b326f7ca",
      "name": "Structured Output Parser6",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "position": [
        27376,
        33120
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are analyzing a user query for movie search. Your job is to determine if the user cares about the **lenght** of the movie (also called **runtime**), and if so:\n\n1. Extract **run time range** that the user refers to or implies\n2. Assign a **weight from 1 to 10** based on how important the year range is in their message\n\nGuidelines:\n- If the user names a specific run time or run time range, give it a high weight (8\u201310)\n- If the user references a vague run time (\"long\", \"short\"), assign a medium weight (4\u20137)\n- If he mentions the run time but it doesn't seem important to him, assign a low weight (1\u20133)\n- Take as a reference that a normal movie would have a range of [90, 120]\n- If the user doesn't specify that the movie must be really short, the botom range must be at least 60\n---\n\n### Output must be ONLY a valid JSON object with this structure:\n\n```json\n{\n  \"runtime_range\": {\n    \"value\": [\n      60,\n      90\n    ],\n    \"weight\": 10\n  }\n}\n\nNow analyze the following user request:\n\"\"\"\n{{ $('normalize_user_input1').item.json.cleanedInput }}\n\"\"\"",
        "hasOutputParser": true,
        "options": {}
      },
      "id": "681c9c96-4126-4690-939b-021cf5d692a5",
      "name": "Runtime",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        27312,
        32896
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini",
          "cachedResultName": "gpt-4.1-mini"
        },
        "options": {}
      },
      "id": "d8d2eb27-b659-44db-820a-093ab02dcd93",
      "name": "OpenAI Chat Model7",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        27376,
        34544
      ],
      "typeVersion": 1.2,
      "credentials": {}
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"main_actors\": [\n    {\n      \"value\": \"Matthew McConaughey\",\n      \"weight\": 3\n    },\n    {\n      \"value\": \"Anne Hathaway\",\n      \"weight\": 4\n    }\n  ]\n}",
        "autoFix": true
      },
      "id": "92b83f2d-e03d-4d1c-aff9-e0e2c2fa17ed",
      "name": "Structured Output Parser7",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "position": [
        27376,
        34336
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are analyzing a user query for movie search. Your job is to determine if the user cares about the **actors** that appear in the movie, and if so:\n\n1. Extract **actors** the the user refers to or implies\n2. Assign a **weight from 1 to 10** based on how important these actors are in their message\n\nGuidelines:\n- If the user names a specific actor, give it a high weight (5\u201310)\n- If the user mentions an actor but it doen't seem important to him, assign a low weight (1\u20133)\n---\n\n### Output must be ONLY a valid JSON object with this structure:\n\n```json\n{\n  \"main_actors\": [\n    {\n      \"value\": \"Matthew McConaughey\",\n      \"weight\": 3\n    },\n    {\n      \"value\": \"Anne Hathaway\",\n      \"weight\": 4\n    }\n  ]\n}\n\nNow analyze the following user request:\n\"\"\"\n{{ $('normalize_user_input1').item.json.cleanedInput }}\n\"\"\"",
        "hasOutputParser": true,
        "options": {}
      },
      "id": "0dbbae71-2cba-4ec4-b6d8-653fb85ad960",
      "name": "Actors",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        27312,
        34112
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini",
          "cachedResultName": "gpt-4.1-mini"
        },
        "options": {}
      },
      "id": "8f1ef350-26c5-4061-af2d-79fdf1d787c5",
      "name": "OpenAI Chat Model8",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        27376,
        35152
      ],
      "typeVersion": 1.2,
      "credentials": {}
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"directors\": [\n    {\n      \"value\": \"Christopher Nolan\",\n      \"weight\": 3\n    }\n  ]\n}",
        "autoFix": true
      },
      "id": "71492c10-c7af-4eca-a7fb-6277f8cbf8d5",
      "name": "Structured Output Parser8",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "position": [
        27376,
        34944
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are analyzing a user query for movie search. Your job is to determine if the user cares about the **director** of the movie, and if so:\n\n1. Extract the **director** that the user refers to or implies\n2. Assign a **weight from 1 to 10** based on how important the director is in their message\n\nGuidelines:\n- If the user names a specific director, give it a high weight (5\u201310)\n- If the user mentions the director but it doen't seem important to him, assign a low weight (1\u20134)\n---\n\n### Output must be ONLY a valid JSON object with this structure:\n\n```json\n{\n  \"directors\": [\n    {\n      \"value\": \"Christopher Nolan\",\n      \"weight\": 3\n    }\n  ]\n}\n\nNow analyze the following user request:\n\"\"\"\n{{ $('normalize_user_input1').item.json.cleanedInput }}\n\"\"\"",
        "hasOutputParser": true,
        "options": {}
      },
      "id": "89ef2c28-5ae6-461e-8c2a-afc0020433bc",
      "name": "Directors",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        27312,
        34720
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are analyzing a user query for movie search. Your job is to determine if the user cares about the **original language** of the movie, and if so:\n\n1. Extract the **original** that the user refers to or implies\n2. Assign a **weight from 1 to 10** based on how important the original language is in their message\n\nGuidelines:\n- If the user names a specific original language, give it a high weight (8\u201310)\n- If the user references a characteristic of the movie that can be associated to a language (\"asiatic\", \"hollywood\"), assign a medium weight (4\u20137)\n- If the user mentions the original language but it doen't seem important to him, assign a low weight (1\u20133)\n- The languages must be within the **codes** from the following list (the ones between parentheses):\nEnglish (en), Italian (it), Spanish (es), Japanese (ja), French (fr), Chinese (zh), Greek (el), Chinese (Simplified) (cn), Russian (ru), German (de), Portuguese (pt), Telugu (te), Hindi (hi), Polish (pl), Hebrew (he), Serbo-Croatian (sh), Dutch (nl), Korean (ko), Swedish (sv), Turkish (tr), Danish (da), Tagalog (tl), Persian/Farsi (fa), Arabic (ar), Zulu (zu), Marathi (mr), Czech (cs), Indonesian (id), Finnish (fi), Latvian (lv), Bengali (bn), Odia (or), Tamil (ta), Malayalam (ml), Hungarian (hu), Serbian (sr), Norwegian (no), Thai (th), Kannada (kn), Lithuanian (lt), Javanese (jv), Ukrainian (uk), Hiri Motu (ho), Kikuyu (ki), Unknown or artificial (xx), Afrikaans (af), Mongolian (mn)\n- In the output, include only these codes; don't include the full name of original languages\n---\n\n### Output must be ONLY a valid JSON object with this structure:\n\n```json\n{\n  \"original_language\": [\n    {\n      \"value\": \"en\",\n      \"weight\": 6\n    },\n    {\n      \"value\": \"fr\",\n      \"weight\": 10\n    }\n  ]\n}\n\nNow analyze the following user request:\n\"\"\"\n{{ $('normalize_user_input1').item.json.cleanedInput }}\n\"\"\"",
        "hasOutputParser": true,
        "options": {}
      },
      "id": "3ee0e24c-bee0-4994-9cc8-c87423b03b87",
      "name": "Language",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        27312,
        33504
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  return {\n    json: item.json.output\n  };\n});\n"
      },
      "id": "0b3113e6-e8c7-415d-a0ba-a35bf8b60967",
      "name": "Code",
      "type": "n8n-nodes-base.code",
      "position": [
        27760,
        31280
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  return {\n    json: item.json.output\n  };\n});\n"
      },
      "id": "7449ca8f-47e7-4883-afab-a3017b0a26ca",
      "name": "Code1",
      "type": "n8n-nodes-base.code",
      "position": [
        27760,
        33712
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "numberInputs": 8
      },
      "id": "771688cc-a418-4929-be48-1efffaa64a7f",
      "name": "Merge",
      "type": "n8n-nodes-base.merge",
      "position": [
        27984,
        32704
      ],
      "typeVersion": 3.2
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  return {\n    json: item.json.output\n  };\n});\n"
      },
      "id": "ec50183f-db92-4ad2-a2f0-845adaad4191",
      "name": "Code3",
      "type": "n8n-nodes-base.code",
      "position": [
        27760,
        31888
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  return {\n    json: item.json.output\n  };\n});\n"
      },
      "id": "5724380a-48f2-465e-8353-99ebfcea19ed",
      "name": "Code4",
      "type": "n8n-nodes-base.code",
      "position": [
        27760,
        32496
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  return {\n    json: item.json.output\n  };\n});\n"
      },
      "id": "cb26556a-cad3-4d53-a159-8d9fcddb5e73",
      "name": "Code5",
      "type": "n8n-nodes-base.code",
      "position": [
        27760,
        33104
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  return {\n    json: item.json.output\n  };\n});\n"
      },
      "id": "7a72bc91-99d3-4975-a2b7-370a0cced0b8",
      "name": "Code6",
      "type": "n8n-nodes-base.code",
      "position": [
        27760,
        34320
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  return {\n    json: item.json.output\n  };\n});\n"
      },
      "id": "e6b478bc-843f-4447-b2e5-3d43489350e5",
      "name": "Code7",
      "type": "n8n-nodes-base.code",
      "position": [
        27760,
        34928
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  return {\n    json: item.json.output\n  };\n});\n"
      },
      "id": "1947dbf1-a381-4218-8748-3e66a94fe1ea",
      "name": "Code8",
      "type": "n8n-nodes-base.code",
      "position": [
        27760,
        30672
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are analyzing a user query for movie search. Your job is to find **movie titles** that the user is actually looking to watch \u2014 not just referenced. Follow these steps carefully:\n\nStep 1: Ignore movie titles that are used as references, such as:\nTitles used in comparisons (e.g., \"like Interstellar\", \"similar to Titanic\")\nExamples or mentions not requested directly\n\nStep 2: From the remaining text, extract any movie titles the user is actually asking for:\n- If the user mentions a clear, **valid title**, extract it and assign a weight of 8\u201310\n- If the user mentions a title that is a close variant or typo of a **valid title**, assign a weight of 4\u20137\n- If the title is vaguely similar to a **valid title**, assign a weight of 1\u20133\n\nStep 3: Output only **valid titles** that are NOT used as references.\n\n---\n\n### Output must be ONLY a valid JSON object with this structure:\n\n```json\n{\n  \"title_keywords\": [\n    {\n      \"value\": \"Toy Story\",\n      \"weight\": 7\n    },\n    {\n      \"value\": \"Interestelar\",\n      \"weight\": 7\n    }\n  ]\n}\n\nNow analyze the following user request:\n\"\"\"\n{{ $('normalize_user_input1').item.json.cleanedInput }}\n\"\"\"",
        "hasOutputParser": true,
        "options": {}
      },
      "id": "5fe3d041-e94d-4d51-a90d-96aac7e0913f",
      "name": "Titles",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        27312,
        30464
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini",
          "cachedResultName": "gpt-4.1-mini"
        },
        "options": {}
      },
      "id": "1355a2ef-99a5-439b-8495-82fc736b243d",
      "name": "OpenAI Chat Model9",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        27376,
        35968
      ],
      "typeVersion": 1.2,
      "credentials": {}
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"title_ref\": [\n    {\n      \"value\": \"Toy Story\",\n      \"weight\": 7\n    },\n    {\n      \"value\": \"Interestelar\",\n      \"weight\": 7\n    }\n  ]\n}",
        "autoFix": true
      },
      "id": "0fa35296-00cd-40ed-a46d-c9cba391fc97",
      "name": "Structured Output Parser9",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "position": [
        27376,
        35760
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are analyzing a user query for movie search. Your job is to find **movie titles** that the user is actually referencing - not movies that he is actually looking for. Follow these steps carefully:\n\nStep 1: Ignore movie titles that user is looking specifically for (e.g. \"A movie called Titanic\", \"I think it's name is Intraestellar\")\n\nStep 2: From the remaining text, extract any movie titles the user is referencing as an example (e.g. \"Similar to Interestellar\", \"Like Toy Story\")\n\nStep 3: Assign to these refrence movies a weight from 1 to 10, being 1 the case when the movie is not rellevant in the users message and 10 the case it is crucial\n\nStep 4: Return a JSON with this information and the following format\n\n---\n\n### Output must be ONLY a valid JSON object with this structure:\n\n```json\n{\n  \"title_ref\": [\n    {\n      \"value\": \"Toy Story\",\n      \"weight\": 7\n    },\n    {\n      \"value\": \"Interestelar\",\n      \"weight\": 7\n    }\n  ]\n}\n\nNow analyze the following user request:\n\"\"\"\n{{ $('normalize_user_input1').item.json.cleanedInput }}\n\"\"\"",
        "hasOutputParser": true,
        "options": {}
      },
      "id": "2cfe7e0e-1941-4550-bedb-bf02431e11ec",
      "name": "Directors1",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        27312,
        35536
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  return {\n    json: item.json.output\n  };\n});\n"
      },
      "id": "2208382f-f058-4ab5-b1df-2480945a093c",
      "name": "Code9",
      "type": "n8n-nodes-base.code",
      "position": [
        27760,
        35536
      ],
      "typeVersion": 2
    },
    {
      "parameters": {},
      "id": "c2d8880e-afa8-400d-9950-8061a6fed5f0",
      "name": "Merge1",
      "type": "n8n-nodes-base.merge",
      "position": [
        28432,
        34016
      ],
      "typeVersion": 3.2
    },
    {
      "parameters": {
        "jsCode": "const combined = Object.assign(\n  {},\n  ...items\n    .filter(item => item && item.json) // Ensure item and item.json exist\n    .map(item => item.json)\n);\n\n// Wrap inside \"FirstJSON\"\nreturn [{\n  json: {\n    FirstJSON: combined\n  }\n}];\n"
      },
      "id": "88de6852-6c68-4f92-8c25-a964f4922914",
      "name": "FirstJSON",
      "type": "n8n-nodes-base.code",
      "position": [
        28208,
        32800
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "// Intentar acceder al primer item del nodo \"FirstJSON\"\nconst firstItems = $input.all('FirstJSON') || [];\nconst firstJson = firstItems[0]?.json?.FirstJSON || {};\n\n// Intentar acceder al primer item del nodo \"SecondJSON\"\nconst secondItems = $input.all('SecondJSON') || [];\nconst secondJson = secondItems[0]?.json?.SecondJSON || {};\n\n\n// Merge year_range\nlet year_range = null;\n\nif (firstJson.year_range && secondJson.year_range) {\n  const avgLower = Math.round(\n    (firstJson.year_range.value[0] + secondJson.year_range.value[0]) / 2\n  );\n  const avgUpper = Math.round(\n    (firstJson.year_range.value[1] + secondJson.year_range.value[1]) / 2\n  );\n  const avgWeight = Math.round(\n    (firstJson.year_range.weight + secondJson.year_range.weight) / 2\n  );\n\n  year_range = {\n    value: [avgLower, avgUpper],\n    weight: avgWeight\n  };\n} else if (firstJson.year_range) {\n  year_range = firstJson.year_range;\n} else if (secondJson.year_range) {\n  year_range = secondJson.year_range;\n} else {\n  year_range = { value: [], weight: 0 };\n}\n\n// Merge runtime_range with average bounds logic\nlet runtime_range = null;\n\nif (firstJson.runtime_range && secondJson.runtime_range) {\n  const avgLower = Math.round(\n    (firstJson.runtime_range.value[0] + secondJson.runtime_range.value[0]) / 2\n  );\n  const avgUpper = Math.round(\n    (firstJson.runtime_range.value[1] + secondJson.runtime_range.value[1]) / 2\n  );\n  const avgWeight = Math.round(\n    (firstJson.runtime_range.weight + secondJson.runtime_range.weight) / 2\n  );\n\n  runtime_range = {\n    value: [avgLower, avgUpper],\n    weight: avgWeight\n  };\n} else if (firstJson.runtime_range) {\n  runtime_range = firstJson.runtime_range;\n} else if (secondJson.runtime_range) {\n  runtime_range = secondJson.runtime_range;\n} else {\n  runtime_range = { value: [], weight: 0 };\n}\n\n// Merge genres from both JSONs with average weights for duplicates\nfunction mergeWeightedArrays(arr1 = [], arr2 = []) {\n  const map = new Map();\n\n  // Helper to add or update map entries\n  function addOrUpdate(item) {\n    if (!item?.value) return;\n    if (map.has(item.value)) {\n      const existing = map.get(item.value);\n      existing.weight = Math.round((existing.weight + item.weight) / 2);\n    } else {\n      map.set(item.value, { ...item });\n    }\n  }\n\n  arr1.forEach(addOrUpdate);\n  arr2.forEach(addOrUpdate);\n\n  return Array.from(map.values());\n}\n\nconst genres = mergeWeightedArrays(\n  firstJson.genres || [],\n  secondJson.genres || []\n);\nconst original_language = mergeWeightedArrays(\n  firstJson.original_language || [], \n  secondJson.original_language || []\n);\nconst main_actors = mergeWeightedArrays(\n  firstJson.main_actors || [], \n  secondJson.main_actors || []\n);\nconst directors = mergeWeightedArrays(\n  firstJson.directors || [], \n  secondJson.directors || []\n);\n\n\n// Build final JSON\nconst finalJson = {\n  title_keywords: firstJson.title_keywords || [],\n  overview_keywords: firstJson.overview_keywords || [],\n  rejected_ids: secondJson.rejected_ids || [],\n  year_range,\n  runtime_range,\n  genres,\n  original_language,\n  main_actors,\n  directors\n};\n\nreturn [{ json: finalJson }];\n"
      },
      "id": "d3f35b74-1cd0-426e-98af-9212bddc224f",
      "name": "Code12",
      "type": "n8n-nodes-base.code",
      "position": [
        28656,
        34016
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "return [{\n  json: {\n    SecondJSON: items[0].json.result_json\n      ? items[0].json.result_json[0]  // Take the first element of result_json\n      : items[0].json                 // Fallback if result_json doesn't exist\n  }\n}];\n"
      },
      "id": "1a35fddb-129c-476c-89d2-f2ca4af0a74e",
      "name": "SecondJSON",
      "type": "n8n-nodes-base.code",
      "position": [
        28208,
        35536
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "movie-chat",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "680ffb4a-e0b4-4775-9b13-46600a8afde3",
      "name": "Entry_chat",
      "type": "n8n-nodes-base.webhook",
      "position": [
        25568,
        33296
      ],
      "webhookId": "a76d0bb4-52a0-4bf4-9d08-4d02e573061d",
      "typeVersion": 2.1
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "9e2774e3-80f4-4270-8275-1cb48b32b797",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "position": [
        29600,
        32992
      ],
      "typeVersion": 1.4
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json['What movie are you looking for?']\nreturn {\n  cleanedInput: input.toLowerCase().replace(/[^a-z0-9\\s]/gi, ''),\n  rawInput: $input.first().json['What movie are you looking for?']\n};\n"
      },
      "id": "64ee8bc9-4dbb-411d-bfca-92794b32e8d7",
      "name": "normalize_user_input1",
      "type": "n8n-nodes-base.code",
      "position": [
        26416,
        33104
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "a11682fb-34f1-486b-83bf-d43853e8fb56",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.title_keywords }}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "title"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "3b7ec878-30fb-413d-bba0-a94f196ccc44",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.genres }}",
                    "rightValue": "true"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "genres"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "6207e214-f927-4371-9dbe-3dbf4bd0a523",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.overview_keywords }}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "overview"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "75090c2f-451e-4986-b5c5-32210996f24f",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.year_range}}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "year"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "b49d6e37-bfde-4dfb-bb06-e03c91b10317",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.runtime_range }}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "runtime"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "8539bf87-0f68-4bd4-bb16-148e44d18d69",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.original_language }}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "original_language"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "f24c9e0a-4087-4758-82c1-d2d8340fd3d2",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.main_actors }}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "main_actors"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "8b58eaaa-5547-4cde-a6dd-8332d66ee943",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.director }}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "director"
            },
            {
              "conditions": {
                "options": {
                  "version": 2,
                  "leftValue": "",
                  "caseSensitive": true,
                  "typeValidation": "strict"
                },
                "combinator": "and",
                "conditions": [
                  {
                    "id": "a9220319-58e6-4923-aa7a-6b2248342676",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "leftValue": "={{ $json.output.reference_movie }}",
                    "rightValue": ""
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "reference"
            }
          ]
        },
        "options": {
          "allMatchingOutputs": true
        }
      },
      "id": "0f417acb-88b7-4876-a36f-1bf96efc945e",
      "name": "Switch1",
      "type": "n8n-nodes-base.switch",
      "position": [
        27008,
        32944
      ],
      "executeOnce": false,
      "typeVersion": 3.2
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are an intelligent assistant that analyzes natural language movie search requests.\n\nYour task is to detect which structured movie fields are semantically relevant or implied in the user's input.\n\nReturn a JSON object with the following fields. For each field, return `true` if the user clearly mentions or implies that it matters to their request. Return `false` otherwise.\n\nRespond ONLY with a valid JSON object. Do not include explanations or comments.\n\nList of fields:\n\n- referece_movie: if the user references another movie title as ane example of what he wants\n- title_keywords \u2014 if the user gives an aproximation of what the title may be or if he gives specific or descriptive words the user wants in the title\n- genres \u2014 genres like Horror, Comedy, Action, Romance\n- overview_keywords \u2014 thematic or content-related words like \u201crobots\u201d, \u201ccars\u201d, \u201cspace\u201d, etc.\n- year_range \u2014 references to specific eras (e.g. \u201c80s\u201d, \u201cbefore 2000\u201d, \u201crecent\u201d)\n- runtime_range \u2014 mentions of movie length (e.g. \u201cshort\u201d, \u201caround 2 hours\u201d, \u201cnot too long\u201d)\n- original_language \u2014 any mention of language preference (e.g. \u201cFrench movie\u201d, \u201cnot dubbed\u201d) or regions that could be assigned to a lenguage (e.g. \"Asiatic\" could be assigned to Japanese or Chinese)\n- main_actors \u2014 specific actors or actresses mentioned\n- director \u2014 any director or filmmaker mentioned\n\nExample output:\n```json\n{\n  \"reference_movie\": true,\n  \"title_keywords\": false,\n  \"genres\": true,\n  \"overview_keywords\": true,\n  \"year_range\": false,\n  \"runtime_range\": true,\n  \"original_language\": false,\n  \"main_actors\": false,\n  \"director\": false\n}\n\nNow analyze the following user request:\n\"\"\"\n{{ $json.cleanedInput }}\n\"\"\"",
        "hasOutputParser": true,
        "options": {}
      },
      "id": "4cd73c42-9ae2-4850-b079-f6eb033c96c3",
      "name": "AI Agent1",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        26640,
        33104
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {}
      },
      "id": "bfcf5caf-cc7e-4243-be1c-9e6c0b5ff8ff",
      "name": "OpenAI Chat Model10",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "position": [
        26704,
        33536
      ],
      "typeVersion": 1.2,
      "credentials": {}
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"reference_movie\": true,\n  \"title_keywords\": false,\n  \"genres\": true,\n  \"overview_keywords\": true,\n  \"year_range\": false,\n  \"runtime_range\": true,\n  \"original_language\": false,\n  \"main_actors\": false,\n  \"director\": false\n}",
        "autoFix": true
      },
      "id": "6232e66c-9ab3-426d-9dd7-d2d6f96e80e1",
      "name": "Structured Output Parser10",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "position": [
        26720,
        33328
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "jsCode": "// Extract message from request body\nconst body = $input.first().json.body || $input.first().json;\nconst userMessage = body.message || body.text || JSON.stringify(body);\n\nreturn [{\n  json: {\n    \"What movie are you looking for?\": userMessage,\n    originalMessage: userMessage,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "cb165fbd-c42f-4c82-9415-377719045f8f",
      "name": "Extract Message1",
      "type": "n8n-nodes-base.code",
      "position": [
        25776,
        33296
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Process reference movies if title_ref exists\nSET @my_json = '[{{ JSON.stringify({ title_ref: $json.title_ref || [] }) }}]';\n\n-- Check if we have reference movies first (without creating temp table)\nSET @has_refs = (\n  SELECT COUNT(*)\n  FROM JSON_TABLE(@my_json, '$[*]' COLUMNS (title_ref JSON PATH '$.title_ref')) AS jt\n  CROSS JOIN JSON_TABLE(jt.title_ref, '$[*]' COLUMNS (title_ref_elem JSON PATH '$')) AS jtr\n);\n\n-- If no reference movies, return empty SecondJSON immediately\nSELECT IF(@has_refs = 0,\n  JSON_ARRAY(JSON_OBJECT(\n    'title_keywords', JSON_ARRAY(),\n    'genres', JSON_ARRAY(),\n    'year_range', JSON_OBJECT('value', JSON_ARRAY(), 'weight', 0),\n    'runtime_range', JSON_OBJECT('value', JSON_ARRAY(), 'weight', 0),\n    'original_language', JSON_ARRAY(),\n    'main_actors', JSON_ARRAY(),\n    'directors', JSON_ARRAY(),\n    'rejected_ids', JSON_ARRAY()\n  )),\n  (\n    -- Process reference movies - use CTEs directly from JSON_TABLE (no temp tables)\n    WITH ref_titles AS (\n      SELECT\n        JSON_UNQUOTE(JSON_EXTRACT(jtr.title_ref_elem, '$.value')) AS value,\n        JSON_UNQUOTE(JSON_EXTRACT(jtr.title_ref_elem, '$.weight')) AS weight\n      FROM JSON_TABLE(@my_json, '$[*]' COLUMNS (title_ref JSON PATH '$.title_ref')) AS jt\n      CROSS JOIN JSON_TABLE(jt.title_ref, '$[*]' COLUMNS (title_ref_elem JSON PATH '$')) AS jtr\n    ),\n    matching_movies AS (\n      SELECT \n        m.runtime, m.original_language, m.genres, m.main_actors,\n        m.director, m.year, rt.weight, m.Id AS rejected_ids\n      FROM ref_titles AS rt\n      JOIN tmdb_movies AS m ON SOUNDEX(m.title) = SOUNDEX(rt.value)\n    ),\n    aggregated_data AS (\n      SELECT\n        ROUND(AVG(weight), 0) AS avg_weight,\n        IFNULL(MIN(runtime), 0) AS runtime_min,\n        IFNULL(MAX(runtime), 0) AS runtime_max,\n        IFNULL(MIN(year), 0) AS year_min,\n        IFNULL(MAX(year), 0) AS year_max\n      FROM matching_movies\n    )\n    SELECT JSON_ARRAY(\n      JSON_OBJECT(\n        'title_keywords', JSON_ARRAY(),\n        'genres', IFNULL((SELECT JSON_ARRAYAGG(JSON_OBJECT('value', genre_name, 'weight', ad.avg_weight))\n          FROM (SELECT DISTINCT TRIM(genre) AS genre_name FROM matching_movies\n          JOIN JSON_TABLE(CONCAT('[\"', REPLACE(REPLACE(genres, ';', ','), ',', '\",\"'), '\"]'),\n          '$[*]' COLUMNS (genre VARCHAR(100) PATH '$')) AS g) AS unique_genres\n          CROSS JOIN aggregated_data ad), JSON_ARRAY()),\n        'year_range', JSON_OBJECT('value', JSON_ARRAY(ad.year_min, ad.year_max), 'weight', ad.avg_weight),\n        'runtime_range', JSON_OBJECT('value', JSON_ARRAY(ad.runtime_min, ad.runtime_max), 'weight', ad.avg_weight),\n        'original_language', IFNULL((SELECT JSON_ARRAYAGG(JSON_OBJECT('value', language_code, 'weight', ad.avg_weight))\n          FROM (SELECT DISTINCT TRIM(lang) AS language_code FROM matching_movies\n          JOIN JSON_TABLE(CONCAT('[\"', REPLACE(REPLACE(original_language, ';', ','), ',', '\",\"'), '\"]'),\n          '$[*]' COLUMNS (lang VARCHAR(10) PATH '$')) AS l) AS unique_languages\n          CROSS JOIN aggregated_data ad), JSON_ARRAY()),\n        'main_actors', IFNULL((SELECT JSON_ARRAYAGG(JSON_OBJECT('value', actor_name, 'weight', ad.avg_weight))\n          FROM (SELECT DISTINCT TRIM(actor) AS actor_name FROM matching_movies\n          JOIN JSON_TABLE(CONCAT('[\"', REPLACE(main_actors, ',', '\",\"'), '\"]'),\n          '$[*]' COLUMNS (actor VARCHAR(255) PATH '$')) AS a) AS unique_actors\n          CROSS JOIN aggregated_data ad), JSON_ARRAY()),\n        'directors', IFNULL((SELECT JSON_ARRAYAGG(JSON_OBJECT('value', director_name, 'weight', ad.avg_weight))\n          FROM (SELECT DISTINCT TRIM(d.director_name) AS director_name FROM matching_movies AS m\n          JOIN JSON_TABLE(CONCAT('[\"', REPLACE(REPLACE(m.director, ';', ','), ',', '\",\"'), '\"]'),\n          '$[*]' COLUMNS (director_name VARCHAR(255) PATH '$')) AS d) AS unique_directors\n          CROSS JOIN aggregated_data ad), JSON_ARRAY()),\n        'rejected_ids', IFNULL((SELECT JSON_ARRAYAGG(rejected_ids) FROM matching_movies), JSON_ARRAY())\n      )\n    )\n    FROM aggregated_data ad\n  )\n) AS result_json;",
        "options": {}
      },
      "id": "f7891a22-cd74-46bd-9a79-9f5dede8c094",
      "name": "SecondJSON SQL1",
      "type": "n8n-nodes-base.mySql",
      "position": [
        28208,
        32992
      ],
      "typeVersion": 2.4,
      "credentials": {}
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "set @json_exclusions ='{{ JSON.stringify({ rejected_ids: $json.rejected_ids || [] }) }}';\nSET @actors_json = '{{ JSON.stringify({ main_actors: $json.main_actors || [] }) }}';\nSET @directors_json = '{{ JSON.stringify({ directors: $json.directors || [] }) }}';\nSET @genres_json = '{{ JSON.stringify({ genres: $json.genres || [] }) }}';\nSET @title_json = '{{ JSON.stringify({ title_keywords: $json.title_keywords || [] }) }}';\nSET @overview_json = '{{ JSON.stringify({ overview_keywords: $json.overview_keywords || [] }) }}';\nSET @lenguage_json = '{{ JSON.stringify({ original_language: $json.original_language || [] }) }}';\nSET @runtime_json = '{{ JSON.stringify({ runtime_range: $json.runtime_range || { value: [], weight: 0 } }) }}';\nSET @year_json = '{{ JSON.stringify({ year_range: $json.year_range || { value: [], weight: 0 } }) }}';\n\nSET SESSION group_concat_max_len = 1000000;\n\nSELECT GROUP_CONCAT(CONCAT(JSON_EXTRACT(actor.value, '$.weight'), ' * CASE WHEN main_actors_soundex LIKE \"%', SOUNDEX(JSON_UNQUOTE(JSON_EXTRACT(actor.value, '$.value'))), '%\" THEN 1 ELSE 0 END') SEPARATOR ' + ') INTO @actor_score_expr\nFROM JSON_TABLE(@actors_json, '$.main_actors[*]' COLUMNS (value JSON PATH '$')) AS actor;\n\nSELECT GROUP_CONCAT(CONCAT(JSON_EXTRACT(director.value, '$.weight'), ' * CASE WHEN directors_soundex LIKE \"%', SOUNDEX(JSON_UNQUOTE(JSON_EXTRACT(director.value, '$.value'))), '%\" THEN 1 ELSE 0 END') SEPARATOR ' + ') INTO @director_score_expr\nFROM JSON_TABLE(@directors_json, '$.directors[*]' COLUMNS (value JSON PATH '$')) AS director;\n\nSELECT GROUP_CONCAT(CONCAT(JSON_EXTRACT(genre.value, '$.weight'), ' * CASE WHEN genres LIKE \"%', JSON_UNQUOTE(JSON_EXTRACT(genre.value, '$.value')), '%\" THEN 1 ELSE 0 END') SEPARATOR ' + ') INTO @genre_score_expr\nFROM JSON_TABLE(@genres_json, '$.genres[*]' COLUMNS (value JSON PATH '$')) AS genre;\n\nSELECT GROUP_CONCAT(CONCAT(JSON_EXTRACT(t.value, '$.weight'), ' * CASE WHEN title_soundex LIKE \"%', SOUNDEX(JSON_UNQUOTE(JSON_EXTRACT(t.value, '$.value'))), '%\" THEN 1 ELSE 0 END') SEPARATOR ' + ') INTO @title_score_expr\nFROM JSON_TABLE(@title_json, '$.title_keywords[*]' COLUMNS (value JSON PATH '$')) AS t;\n\nSELECT GROUP_CONCAT(CONCAT(JSON_EXTRACT(k.value, '$.weight'), ' * CASE WHEN overview LIKE \"%', JSON_UNQUOTE(JSON_EXTRACT(k.value, '$.value')), '%\" THEN 1 ELSE 0 END') SEPARATOR ' + ') INTO @overview_score_expr\nFROM JSON_TABLE(@overview_json, '$.overview_keywords[*]' COLUMNS (value JSON PATH '$')) AS k;\n\nSELECT GROUP_CONCAT(CONCAT(JSON_EXTRACT(lang.value, '$.weight'), ' * CASE WHEN original_language = \"', JSON_UNQUOTE(JSON_EXTRACT(lang.value, '$.value')), '\" THEN 1 ELSE 0 END') SEPARATOR ' + ') INTO @language_score_expr\nFROM JSON_TABLE(@lenguage_json, '$.original_language[*]' COLUMNS (value JSON PATH '$')) AS lang;\n\nSELECT CONCAT('CASE ', 'WHEN runtime >= ', JSON_EXTRACT(j.value, '$.value[0]'), ' AND runtime <= ', JSON_EXTRACT(j.value, '$.value[1]'), ' THEN ', JSON_EXTRACT(j.value, '$.weight'), ' WHEN runtime < ', JSON_EXTRACT(j.value, '$.value[0]'), ' THEN ', JSON_EXTRACT(j.value, '$.weight'), '/(1 + LN(1 + ABS(', JSON_EXTRACT(j.value, '$.value[0]'), ' - runtime)))', ' WHEN runtime > ', JSON_EXTRACT(j.value, '$.value[1]'), ' THEN ', JSON_EXTRACT(j.value, '$.weight'), '/(1 + LN(1 + ABS(', JSON_EXTRACT(j.value, '$.value[1]'), ' - runtime)))', ' END') INTO @runtime_score_expr\nFROM JSON_TABLE(@runtime_json, '$.runtime_range' COLUMNS (value JSON PATH '$')) AS j;\n\nSELECT CONCAT('CASE ', 'WHEN year >= ', JSON_EXTRACT(j.value, '$.value[0]'), ' AND year <= ', JSON_EXTRACT(j.value, '$.value[1]'), ' THEN ', JSON_EXTRACT(j.value, '$.weight'), ' WHEN year < ', JSON_EXTRACT(j.value, '$.value[0]'), ' THEN ', JSON_EXTRACT(j.value, '$.weight'), '/(1 + LN(1 + ABS(', JSON_EXTRACT(j.value, '$.value[0]'), ' - year)))', ' WHEN year > ', JSON_EXTRACT(j.value, '$.value[1]'), ' THEN ', JSON_EXTRACT(j.value, '$.weight'), '/(1 + LN(1 + ABS(', JSON_EXTRACT(j.value, '$.value[1]'), ' - year)))', ' END') INTO @year_score_expr\nFROM JSON_TABLE(@year_json, '$.year_range' COLUMNS (value JSON PATH '$')) AS j;\n\nSET @sql = CONCAT('WITH rejected AS (SELECT id FROM JSON_TABLE(', QUOTE(@json_exclusions), ', \"$.rejected_ids[*]\" COLUMNS (id INT PATH \"$\")) AS rej), movies_with_score AS (SELECT title, id, year, ', IFNULL(@actor_score_expr, '0'), ' + ', IFNULL(@director_score_expr, '0'), ' + ', IFNULL(@genre_score_expr, '0'), ' + ', IFNULL(@title_score_expr, '0'), ' + ', IFNULL(@overview_score_expr, '0'), ' + ', IFNULL(@language_score_expr, '0'), ' + ', IFNULL(@runtime_score_expr, '0'), ' + ', IFNULL(@year_score_expr, '0'), ' AS score FROM tmdb_movies WHERE id NOT IN (SELECT id FROM rejected)), ranked_movies AS (SELECT *, DENSE_RANK() OVER (ORDER BY score DESC) AS rank_col FROM movies_with_score) SELECT title, id, year, score FROM ranked_movies ORDER BY rank_col ASC LIMIT 5');\n\nPREPARE stmt FROM @sql;\nEXECUTE stmt;\nDEALLOCATE PREPARE stmt;",
        "options": {}
      },
      "id": "411daf5b-3d5a-44eb-aeab-c921a27857a9",
      "name": "Execute SQL Query1",
      "type": "n8n-nodes-base.mySql",
      "position": [
        28608,
        32992
      ],
      "typeVersion": 2.4,
      "credentials": {}
    },
    {
      "parameters": {
        "jsCode": "// Split results for parallel TMDB API calls\nconst results = $input.all();\nreturn results.map(item => ({ json: { title: item.json.title, id: item.json.id, year: item.json.year, score: item.json.score } }));"
      },
      "id": "c43d384d-b357-4b5e-968e-9a37ea84a2b1",
      "name": "Split for TMDB1",
      "type": "n8n-nodes-base.code",
      "position": [
        28800,
        32992
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "url": "=https://api.themoviedb.org/3/search/movie",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "api_key",
              "value": "YOUR_TMDB_API_KEY_HERE"
            },
            {
              "name": "query",
              "value": "={{ $json.title }}"
            },
            {
              "name": "year",
              "value": "={{ $json.year }}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 5000
        }
      },
      "id": "b60c104f-838e-42bb-b71d-abb99402e7ed",
      "name": "TMDB Search1",
      "type": "n8n-nodes-base.httpRequest",
      "position": [
        29008,
        32992
      ],
      "typeVersion": 4.2
    },
    {
      "parameters": {
        "jsCode": "// Process ALL input items - match each TMDB result with corresponding SQL data by TITLE\n// Get all SQL data items from 'Split for TMDB' node (these have the score)\nconst sqlItems = $('Split for TMDB1').all();\n\n// Create a map of SQL data by title for reliable matching\nconst sqlDataMap = {};\nsqlItems.forEach(item => {\n  const title = item.json.title?.toLowerCase() || '';\n  if (title) {\n    sqlDataMap[title] = item.json;\n  }\n});\n\n// Process each input item (each TMDB response from TMDB Search)\nconst results = [];\n\nfor (let i = 0; i < $input.all().length; i++) {\n  // Get TMDB response (structure: { page: 1, results: [...] })\n  const tmdbResponse = $input.all()[i].json;\n  \n  // Get SQL data by index first (fallback)\n  const sqlDataByIndex = sqlItems[i]?.json || {};\n  \n  // Handle TMDB errors/timeouts gracefully\n  const tmdbError = tmdbResponse.error || null;\n  const tmdbResults = tmdbResponse.results || [];\n  \n  // Find best match (exact title match preferred, then closest year)\n  let bestMatch = null;\n  let tmdbFound = false;\n  let matchedSqlData = sqlDataByIndex; // Default to index-based match\n  \n  if (!tmdbError && tmdbResults.length > 0) {\n    tmdbFound = true;\n    // Try exact title match first\n    bestMatch = tmdbResults.find(r => {\n      const tmdbTitle = r.title?.toLowerCase() || '';\n      // Try to find matching SQL data by title\n      if (sqlDataMap[tmdbTitle]) {\n        matchedSqlData = sqlDataMap[tmdbTitle];\n      }\n      return tmdbTitle === sqlDataByIndex.title?.toLowerCase();\n    });\n    \n    // If no exact match, try closest year\n    if (!bestMatch && sqlDataByIndex.year) {\n      bestMatch = tmdbResults.reduce((best, current) => {\n        const currentDiff = Math.abs((current.release_date ? parseInt(current.release_date.split('-')[0]) : 0) - sqlDataByIndex.year);\n        const bestDiff = best ? Math.abs((best.release_date ? parseInt(best.release_date.split('-')[0]) : 0) - sqlDataByIndex.year) : Infinity;\n        return currentDiff < bestDiff ? current : best;\n      }, null);\n    }\n    \n    // Fallback to first result\n    if (!bestMatch) {\n      bestMatch = tmdbResults[0];\n      // Try to match SQL data by title from best match\n      const bestMatchTitle = bestMatch.title?.toLowerCase() || '';\n      if (sqlDataMap[bestMatchTitle]) {\n        matchedSqlData = sqlDataMap[bestMatchTitle];\n      }\n    }\n  }\n  \n  // Determine missing fields\n  const missingFields = [];\n  if (tmdbError || !tmdbFound) {\n    missingFields.push('poster', 'description', 'rating', 'backdrop_path', 'vote_count');\n  } else if (bestMatch) {\n    if (!bestMatch.poster_path) missingFields.push('poster');\n    if (!bestMatch.overview) missingFields.push('description');\n    if (!bestMatch.vote_average) missingFields.push('rating');\n    if (!bestMatch.backdrop_path) missingFields.push('backdrop_path');\n    if (!bestMatch.vote_count) missingFields.push('vote_count');\n  }\n  \n  // IMPORTANT: Preserve score from matched SQL data\n  const preservedScore = matchedSqlData.score || sqlDataByIndex.score || 0;\n  \n  // Add enriched movie data to results\n  results.push({\n    json: {\n      id: bestMatch?.id || matchedSqlData.id || sqlDataByIndex.id || `movie-${Date.now()}-${i}`,\n      tmdb_id: bestMatch?.id || null,\n      title: bestMatch?.title || matchedSqlData.title || sqlDataByIndex.title,\n      year: bestMatch?.release_date ? parseInt(bestMatch.release_date.split('-')[0]) : matchedSqlData.year || sqlDataByIndex.year || new Date().getFullYear(),\n      poster: bestMatch?.poster_path ? `https://image.tmdb.org/t/p/w500${bestMatch.poster_path}` : null,\n      description: bestMatch?.overview || (tmdbError ? 'TMDB API timeout or error. Using basic movie information.' : (tmdbFound ? 'No additional information available from TMDB for this movie.' : 'TMDB API information not available for this movie.')),\n      rating: bestMatch?.vote_average ? (bestMatch.vote_average / 10) * 10 : null,\n      vote_count: bestMatch?.vote_count || null,\n      score: preservedScore,  // \u2705 PRESERVED FROM SQL DATA (matched by title or index)\n      original_title: bestMatch?.original_title || matchedSqlData.title || sqlDataByIndex.title,\n      backdrop_path: bestMatch?.backdrop_path ? `https://image.tmdb.org/t/p/w1280${bestMatch.backdrop_path}` : null,\n      tmdb_available: tmdbFound && !tmdbError,\n      missing_fields: missingFields\n    }\n  });\n}\n\n// Return all enriched movies\nreturn results;"
      },
      "id": "5a55b6df-b236-4b3d-a78e-2f174f77e80e",
      "name": "Enrich with TMDB1",
      "type": "n8n-nodes-base.code",
      "position": [
        29200,
        32992
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "// Format final response with all movies sorted by score\nconst results = $input.all();\n\n// Sort by score (descending) - best match first\nconst sortedMovies = results\n  .map(item => item.json)\n  .filter(movie => movie.title)\n  .sort((a, b) => (b.score || 0) - (a.score || 0));\n\nconst titles = sortedMovies.map(m => m.title);\n\n// Build response with missing info indicators\nconst movies = sortedMovies.map((movie, index) => {\n  const missingFields = movie.missing_fields || [];\n  const missingInfoNote = missingFields.length > 0 \n    ? ` (Note: ${missingFields.join(', ')} ${missingFields.length === 1 ? 'is' : 'are'} not available from TMDB)` \n    : '';\n  \n  return {\n    id: movie.tmdb_id || movie.id || `movie-${index}-${Date.now()}`,\n    title: movie.title || 'Unknown',\n    year: movie.year || new Date().getFullYear(),\n    poster: movie.poster || null,\n    description: movie.description || `A recommended film: ${movie.title}`,\n    rating: movie.rating || null,\n    score: movie.score || 0,\n    backdrop_path: movie.backdrop_path || null,\n    vote_count: movie.vote_count || null,\n    tmdb_available: movie.tmdb_available !== false,\n    missing_fields: missingFields,\n    missing_info_note: missingInfoNote\n  };\n});\n\nreturn [{\n  json: {\n    message: sortedMovies.length > 0 ? `I found ${sortedMovies.length} movie${sortedMovies.length > 1 ? 's' : ''} for you!` : \"No movies found\",\n    allTitles: titles,\n    titlesString: titles.join(\", \"),\n    movies: movies,\n    success: sortedMovies.length > 0\n  }\n}];"
      },
      "id": "4cb6c80f-ab05-437a-a6aa-24886e46f2f8",
      "name": "Format Response1",
      "type": "n8n-nodes-base.code",
      "position": [
        29408,
        32992
      ],
      "typeVersion": 2
    }
  ],
  "pinData": {},
  "connections": {
    "Code": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Code1": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 5
          }
        ]
      ]
    },
    "Code3": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Code4": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Code5": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Code6": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 6
          }
        ]
      ]
    },
    "Code7": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 7
          }
        ]
      ]
    },
    "Code8": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code9": {
      "main": [
        [
          {
            "node": "SecondJSON SQL1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "FirstJSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Actors": {
      "main": [
        [
          {
            "node": "Code6",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code12": {
      "main": [
        [
          {
            "node": "Execute SQL Query1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Genres": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Code12",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "Merge Relevance Flags",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge Relevance Flags",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge Relevance Flags",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge Relevance Flags",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge Relevance Flags",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge Relevance Flags",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge Relevance Flags",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge Relevance Flags",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge Relevance Flags",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Titles": {
      "main": [
        [
          {
            "node": "Code8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Runtime": {
      "main": [
        [
          {
            "node": "Code5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch1": {
      "main": [
        [
          {
            "node": "Titles",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Genres",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Keywords",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Year range",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Runtime",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Language",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Actors",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Directors",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Directors1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Keywords": {
      "main": [
        [
          {
            "node": "Code3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Language": {
      "main": [
        [
          {
            "node": "Code1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent1": {
      "main": [
        [
          {
            "node": "Switch1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Directors": {
      "main": [
        [
          {
            "node": "Code7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FirstJSON": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Directors1": {
      "main": [
        [
          {
            "node": "Code9",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Entry_chat": {
      "main": [
        [
          {
            "node": "Extract Message1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge JSON": {
      "main": [
        [
          {
            "node": "Execute SQL Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SecondJSON": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Year range": {
      "main": [
        [
          {
            "node": "Code4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TMDB Search": {
      "main": [
        [
          {
            "node": "Enrich with TMDB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare JSON": {
      "main": [
        [
          {
            "node": "SecondJSON SQL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TMDB Search1": {
      "main": [
        [
          {
            "node": "Enrich with TMDB1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SecondJSON SQL": {
      "main": [
        [
          {
            "node": "Merge JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split for TMDB": {
      "main": [
        [
          {
            "node": "TMDB Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Message": {
      "main": [
        [
          {
            "node": "normalize_user_input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SecondJSON SQL1": {
      "main": [
        [
          {
            "node": "SecondJSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split for TMDB1": {
      "main": [
        [
          {
            "node": "TMDB Search1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich with TMDB": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Message1": {
      "main": [
        [
          {
            "node": "normalize_user_input1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response1": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enrich with TMDB1": {
      "main": [
        [
          {
            "node": "Format Response1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute SQL Query": {
      "main": [
        [
          {
            "node": "Split for TMDB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Genres",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Execute SQL Query1": {
      "main": [
        [
          {
            "node": "Split for TMDB1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "Structured Output Parser2",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Titles",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "Language",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser3",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model4": {
      "ai_languageModel": [
        [
          {
            "node": "Keywords",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser4",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model5": {
      "ai_languageModel": [
        [
          {
            "node": "Year range",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser5",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model6": {
      "ai_languageModel": [
        [
          {
            "node": "Runtime",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser6",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model7": {
      "ai_languageModel": [
        [
          {
            "node": "Actors",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser7",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model8": {
      "ai_languageModel": [
        [
          {
            "node": "Directors",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser8",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model9": {
      "ai_languageModel": [
        [
          {
            "node": "Directors1",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser9",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model10": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser10",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "normalize_user_input": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Relevance Flags": {
      "main": [
        [
          {
            "node": "Comprehensive Extraction Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "normalize_user_input1": {
      "main": [
        [
          {
            "node": "AI Agent1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Genres",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Extract Extraction Output": {
      "main": [
        [
          {
            "node": "Prepare JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "AI Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser2": {
      "ai_outputParser": [
        [
          {
            "node": "Titles",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser3": {
      "ai_outputParser": [
        [
          {
            "node": "Language",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser4": {
      "ai_outputParser": [
        [
          {
            "node": "Keywords",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser5": {
      "ai_outputParser": [
        [
          {
            "node": "Year range",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser6": {
      "ai_outputParser": [
        [
          {
            "node": "Runtime",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser7": {
      "ai_outputParser": [
        [
          {
            "node": "Actors",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser8": {
      "ai_outputParser": [
        [
          {
            "node": "Directors",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser9": {
      "ai_outputParser": [
        [
          {
            "node": "Directors1",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser10": {
      "ai_outputParser": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Comprehensive Extraction Agent": {
      "main": [
        [
          {
            "node": "Extract Extraction Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model - Extraction": {
      "ai_languageModel": [
        [
          {
            "node": "Comprehensive Extraction Agent",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser - Extraction",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser - Extraction": {
      "ai_outputParser": [
        [
          {
            "node": "Comprehensive Extraction Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "cd2a8d74-a0ce-42e0-9a8e-0d9eb6a59712",
  "meta": {},
  "id": "nXskwgOfIgmkoCBN",
  "tags": []
}